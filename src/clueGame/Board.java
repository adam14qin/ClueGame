package clueGame;

import java.awt.Color;
import java.awt.Dimension;
import java.awt.Graphics;
import java.awt.GridLayout;
import java.awt.Rectangle;
import java.awt.event.MouseEvent;
import java.awt.event.MouseListener;
import java.io.File;
import java.io.FileNotFoundException;
import java.io.FileReader;
import java.util.ArrayList;
import java.util.Collections;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Map;
import java.util.Random;
import java.util.Scanner;
import java.util.Set;

import javax.swing.JOptionPane;
import javax.swing.JPanel;

import javafx.scene.text.Font;

import java.lang.reflect.Field;

public class Board extends JPanel{
	public static final int MAX_BOARD_SIZE = 50;
	private int numRows, numColumns;
	private BoardCell[][] board;

	private String roomConfigName;
	private String boardConfigName;
	private String playerConfigName; 
	private String weaponConfigName; 
	private Map<int[], String> roomNameLocations; 
	
	private ArrayList<Player> players;
	private HumanPlayer human; 
	public Player currentPlayer;
	private ArrayList<String> habitableRooms;
	public Map<Character, String> rooms;
	private ArrayList<String> weapons;
	private Map<CardType, ArrayList<Card>> unseen;
	public int playerIndex; 
	public int dieRoll;

	private Map<BoardCell, Set<BoardCell>> adjMtx = new HashMap<BoardCell, Set<BoardCell>>();
	private Set<BoardCell> visited = new HashSet<BoardCell>();
	private Set<BoardCell> targets = new HashSet<BoardCell>();

	public Solution answer = new Solution(); 

	private ArrayList<Card> deck = new ArrayList<>();

	// Variable used for singleton pattern
	private static Board theInstance = new Board();
	
	// Constructor is private to ensure only one can be created
	private Board() {
		setConfigFiles("SSAL_ClueLayout.csv", "SSAL_ClueLegend.txt", "SSAL_Weapons.txt", "SSAL_Players.txt");
		players = new ArrayList<>(); 
		habitableRooms = new ArrayList<>(); 
		rooms = new HashMap<Character, String>();
		weapons = new ArrayList<>(); 
		unseen = new HashMap<>();
		roomNameLocations = new HashMap<int[], String>(); 
		unseen.put(CardType.WEAPON, new ArrayList<Card>());
		unseen.put(CardType.PERSON, new ArrayList<Card>());
		unseen.put(CardType.ROOM, new ArrayList<Card>());
		adjMtx = new HashMap<BoardCell, Set<BoardCell>>();
		addMouseListener(new ClickOnBoard());
		setSize(ClueGame.CELL_PIXEL_SIZE*numRows, ClueGame.CELL_PIXEL_SIZE*numColumns);
	}

	// This method returns the only Board
	public static Board getInstance() { return theInstance; }

	// Instance getters
	public int getNumRows() { return numRows; }
	public int getNumColumns() { return numColumns;	}
	public Map<Character, String> getLegend() { return rooms; }

	// Return the BoardCell at (row, column)
	public BoardCell getCellAt(int row, int column) {
		if (row < numRows && column < numColumns && row >= 0 && column >= 0)
			return board[row][column];
		else
			return null;
	}
	
	// Store the legend and layout configuration file names
	public void setConfigFiles(String layoutFileName, String legendFileName, String weaponFileName, String playerFileName) {
		roomConfigName = legendFileName;
		boardConfigName = layoutFileName;
		weaponConfigName = weaponFileName; 
		playerConfigName = playerFileName;
	}

	// Read from the configuration files and initialize the Board
	public void initialize() {
		try {
			loadRoomConfig();
			loadBoardConfig();
			loadPlayerConfig(); 
			loadWeaponConfig();
			answer = generateAnswer(); 
			dealCards();

		} catch (BadConfigFormatException | FileNotFoundException e) {
			e.printStackTrace();
		}
		calcAdjacencies();
	}

	private Solution generateAnswer() {
		Random rand = new Random();
		Player playerAnswer = players.get(rand.nextInt(players.size())); 
		String roomAnswer = habitableRooms.get(rand.nextInt(habitableRooms.size()));
		String weaponAnswer = weapons.get(rand.nextInt(weapons.size())); 
		return new Solution(new Card(CardType.WEAPON, weaponAnswer), new Card(CardType.PERSON, playerAnswer.getName()), new Card(CardType.ROOM, roomAnswer)); 
	}

	public boolean checkAccusation(Solution accusation) {
		
			if(accusation.equals(answer)) //answer is generated by generateAnswer in initialize()
			{
				if(currentPlayer.equals(human))
				{
				JOptionPane.showMessageDialog(this, "Correct! You win!", "Accusation", JOptionPane.INFORMATION_MESSAGE);
				System.exit(0);
				return true;
				} else {
					JOptionPane.showMessageDialog(this, currentPlayer.getName() + " guessed Correctly!\nThe answer was " + answer.getPlayer().getCardName() + " " + answer.getWeapon().getCardName() + " " + answer.getRoom().getCardName(), "Accusation", JOptionPane.INFORMATION_MESSAGE);
				}
			}
		JOptionPane.showMessageDialog(this, "False, that is not right.", "Accusation", JOptionPane.INFORMATION_MESSAGE);
		human.isFinished = true;
		targets.clear();
		repaint(); 
		return false;
	}

	public void advancePlayer() {
		playerIndex = (playerIndex+1)%getPlayers().size();
		currentPlayer = getPlayers().get(playerIndex%getPlayers().size()); 
		if(currentPlayer.equals(getHuman()))
		{
			getHuman().isFinished = false;
		}
		rollDie(); 
		calcTargets(currentPlayer.getRow(), currentPlayer.getCol(), dieRoll);
		
	}
	
	public void rollDie()
	{
		Random ran = new Random();
		dieRoll = ran.nextInt(6)+1;
	}
	
	public Card handleSuggestion(ArrayList<Player> playersInGame, int accuser, Solution suggestion) {
		String name = suggestion.getPlayer().getCardName();
		Player accusingPlayer = players.get(accuser); 
		for(Player x : players)
		{
			if(x.getName().equals(name))
			{
				x.moveToSpot(board[accusingPlayer.getRow()][accusingPlayer.getCol()], this, true); 
				targets.clear();
				repaint();
				break;
			}
		}
		for(int i=accuser+1; i<accuser+playersInGame.size(); i++)//start handling suggestion from the player next to accuser
		{
			Card x = playersInGame.get(i%playersInGame.size()).disproveSuggestion(this, suggestion);
			if(x != null)
			{
				unseen.get(x.getCardType()).remove(x); 
			}
			if(x != null){
				return x; 
			}
		}
		return null; 
	}

	private void dealCards() {
		ArrayList<Card> tempDeck = new ArrayList<>(); 
		tempDeck.addAll(deck); 
		Collections.shuffle(tempDeck);
		//remove solution cards from the deck
		for(int i = tempDeck.size()-1; i>=0; i--)
		{
			if(tempDeck.get(i).equals(answer.getPlayer()))
				tempDeck.remove(i);
			else if(tempDeck.get(i).equals(answer.getRoom()))
				tempDeck.remove(i);
			else if(tempDeck.get(i).equals(answer.getWeapon()))
				tempDeck.remove(i);
		}
		int currentPlayer = 0; 
		while(!tempDeck.isEmpty())
		{
			players.get(currentPlayer%players.size()).getHand().add(tempDeck.get(0)); 
			tempDeck.remove(0); 
			currentPlayer++; 
			
		}
	}

	// Read the legend file
	public void loadRoomConfig() throws FileNotFoundException, BadConfigFormatException{
		// File reader objects
		FileReader reader = new FileReader(roomConfigName);
		Scanner in = null;
		rooms.clear();
		deck.clear(); 
		try {
			// Initialize file scanner
			in = new Scanner(reader);

			// Iterate through definitions of rooms
			while(in.hasNextLine()){
				String theLine = in.nextLine();
				String[] theChunks = theLine.split(", ");

				// Error condition: Row of legend doesn't have 3 comma separated values
				if (theChunks.length != 5)
					throw new BadConfigFormatException("Invalid legend entry: " + theLine);

				// Error condition: Type of room is not 'Other' or 'Card'
				else if (!(theChunks[2].equals("Other") || theChunks[2].equals("Card")))
					throw new BadConfigFormatException("Invalid room type: " + theChunks[2]);

				// Store the room into the map
				rooms.put(theChunks[0].charAt(0), theChunks[1]);
				//Push the cell for name into map
				if(!theChunks[2].equals("Other"))
				{
					int[] nameCell = {Integer.parseInt(theChunks[3].trim()), Integer.parseInt(theChunks[4].trim())}; 
				roomNameLocations.put(nameCell, theChunks[1]);
				}
			}
		} finally {
			// Cleanup the scanner, even if an exception was thrown
			if (in != null)
				in.close();
		}
		for(char x : rooms.keySet())
		{
			if(x != 'W' && x!= 'X')
			{
				deck.add(new Card(CardType.ROOM, rooms.get(x))); 
				unseen.get(CardType.ROOM).add(new Card(CardType.ROOM, rooms.get(x))); 
				habitableRooms.add(rooms.get(x)); 
			}
		}
	}

	// Read the layout file
	public void loadBoardConfig() throws FileNotFoundException, BadConfigFormatException {
		Scanner fileScanner2;
		ArrayList<String[]> rows = new ArrayList<>(); 
		try {
			fileScanner2 = new Scanner(new File(boardConfigName));
			while (fileScanner2.hasNextLine()){
				String [] row = fileScanner2.nextLine().split(",");
				rows.add(row);  
			}
			int supposedSize = rows.get(0).length;
			for(String[] tempArray : rows)
			{
				if(tempArray.length != supposedSize)
				{
					throw new BadConfigFormatException();
				}
			}
			board = new BoardCell[rows.size()][rows.get(0).length]; 
			for(int i=0; i<rows.size(); i++)
			{
				for(int z=0; z<rows.get(i).length; z++)
				{
					board[i][z] = new BoardCell(i, z, rows.get(i)[z].trim());
					if(!rooms.containsKey(board[i][z].getInitial()))
					{
						throw new BadConfigFormatException("" + board[i][z].getInitial()); 
					}
				}
			}
			numRows = rows.size();
			numColumns = rows.get(0).length; 
			fileScanner2.close();
		} catch (FileNotFoundException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
	}

	public void loadPlayerConfig() throws FileNotFoundException, BadConfigFormatException
	{
		players.clear();
		// File reader objects
		FileReader reader = new FileReader(playerConfigName);
		Scanner in = null;
		try {
			// Initialize file scanner
			in = new Scanner(reader);

			// Iterate through definitions of rooms
			while(in.hasNextLine()){
				String theLine = in.nextLine();
				String[] theChunks = theLine.split(", ");

				// Error condition: Row of legend doesn't have 3 comma separated values
				if (theChunks.length != 5)
					throw new BadConfigFormatException("Invalid legend entry: " + theLine);

				// Error condition: Type of room is not 'Other' or 'Card'

				// Store the room into the map
				deck.add(new Card(CardType.PERSON, theChunks[1])); 
				unseen.get(CardType.PERSON).add(new Card(CardType.PERSON, theChunks[1])); 
				if(theChunks[0].charAt(0)=='P')
				{
					human = new HumanPlayer(theChunks[1], Integer.parseInt(theChunks[2]), Integer.parseInt(theChunks[3]), convertColor(theChunks[4]));
					playerIndex = players.size()-1; 
					players.add(human);
					currentPlayer = human;
				}
				else
				{
					players.add(new ComputerPlayer(theChunks[1], Integer.parseInt(theChunks[2]), Integer.parseInt(theChunks[3]), convertColor(theChunks[4])));
				}
			}	

		} finally {
			// Cleanup the scanner, even if an exception was thrown
			if (in != null)
				in.close();
		}
	}

	public void loadWeaponConfig() throws FileNotFoundException, BadConfigFormatException {
		// File reader objects
		weapons.clear(); 
		FileReader reader = new FileReader(weaponConfigName);
		Scanner in = null;
		try {
			// Initialize file scanner
			in = new Scanner(reader);

			// Iterate through definitions of rooms
			while(in.hasNextLine()){
				String theLine = in.nextLine();
				deck.add(new Card(CardType.WEAPON, theLine)); 
				unseen.get(CardType.WEAPON).add(new Card(CardType.WEAPON,theLine)); 
				weapons.add(theLine); 
			}	
		} finally {
			// Cleanup the scanner, even if an exception was thrown
			if (in != null)
				in.close();
		}
	}



	private void calcAdjacencies() {
		// Complexity: O(n)-> n=number of cells
		for (int i = 0; i < numRows; i++) {
			for (int j = 0; j < numColumns; j++) {
				// Get cell of interest
				BoardCell bc = board[i][j];

				// Ensure entry exists in map
				if (!adjMtx.containsKey(bc))
					adjMtx.put(bc, new HashSet<BoardCell>());

				// Add left, right, up, down cells conditionally
				// If inside a walkway
				if (board[i][j].isWalkway()){

					if (i > 0 && (board[i-1][j].isWalkway() || (board[i-1][j].isDoorway() && board[i-1][j].getDoorDirection() == DoorDirection.DOWN))) 				
						adjMtx.get(bc).add(board[i-1][j]);		
					if (i < numRows - 1 && (board[i+1][j].isWalkway() || (board[i+1][j].isDoorway() && board[i+1][j].getDoorDirection() == DoorDirection.UP))) 	
						adjMtx.get(bc).add(board[i+1][j]);
					if (j > 0 && (board[i][j-1].isWalkway() || (board[i][j-1].isDoorway() && board[i][j-1].getDoorDirection() == DoorDirection.RIGHT))) 				
						adjMtx.get(bc).add(board[i][j-1]);
					if (j < numColumns - 1 && (board[i][j+1].isWalkway() || (board[i][j+1].isDoorway() && board[i][j+1].getDoorDirection() == DoorDirection.LEFT))) 
						adjMtx.get(bc).add(board[i][j+1]);
				}

				else if (board[i][j].isDoorway()){
					if (i > 0 && board[i-1][j].isWalkway()) 				
						adjMtx.get(bc).add(board[i-1][j]);			
					if (i < numRows - 1 && board[i+1][j].isWalkway()) 		
						adjMtx.get(bc).add(board[i+1][j]);
					if (j > 0 && board[i][j-1].isWalkway()) 				
						adjMtx.get(bc).add(board[i][j-1]);
					if (j < numColumns - 1 && board[i][j+1].isWalkway()) 	
						adjMtx.get(bc).add(board[i][j+1]);
				}
			}
		}
	}

	public void calcTargets(int row, int column, int pathLength) {
		// Empty out the visited/targets lists
		visited.clear();
		targets.clear();

		// Add the start location to visited
		BoardCell startCell = board[row][column];
		visited.add(startCell);

		// Kick off the recursion
		findAllTargets(startCell, pathLength);
	}

	private void findAllTargets(BoardCell startCell, int pathLength) {
		// Iterate through adjacent BoardCell(s)
		for (BoardCell adj : adjMtx.get(startCell)) {
			// Don't double back on our path
			if (visited.contains(adj))
				continue;

			// Protect ourselves from doubling back in the next round
			visited.add(adj);

			// Add a target if we expired the pathLength counter, otherwise recurse
			if (pathLength == 1 || adj.isDoorway())
				targets.add(adj);
			else
				findAllTargets(adj, pathLength - 1);

			// Clean adjacent cell out of visited set
			visited.remove(adj);
		}
	}
	
	public void draw(Graphics g)
	{
		drawBoardCells(g);
		drawRoomNames(g);
		drawPlayers(g); 
		
	}
	
	private void drawBoardCells(Graphics g)
	{
		for(int row = 0; row < board.length; row++)
		{
			for(int col =0; col < board[row].length; col++)
			{
				board[row][col].draw(this, g, (targets.contains(board[row][col]) && (currentPlayer.equals(human)) ? true : false));
			}
		}
	}
	
	private void drawRoomNames(Graphics g)
	{
		for(int[] x : roomNameLocations.keySet())
		{
			g.setColor(Color.white);
			int fontSize = (int)((double)(ClueGame.CELL_PIXEL_SIZE)*0.66); 
			g.setFont(new java.awt.Font("Courier New", 1, fontSize));
			g.drawString(roomNameLocations.get(x),x[1]*ClueGame.CELL_PIXEL_SIZE, x[0]*ClueGame.CELL_PIXEL_SIZE);
		}
	}
	
	private void drawPlayers(Graphics g)
	{
		for(Player player: players)
		{
			player.draw(g);
		}
	}
	
	protected void paintComponent(Graphics g) 
	{
		super.paintComponent(g);
		this.draw(g);
	}

	public Set<BoardCell> getAdjList(int row, int column) {
		return adjMtx.get(board[row][column]);
	}

	public Set<BoardCell> getTargets() {
		return targets;
	} 

	public ArrayList<Card> getDeck()
	{
		return deck; 
	}

	public ArrayList<Player> getPlayers()
	{
		return players; 
	}

	public ArrayList<String> getWeapons()
	{
		return weapons; 
	}

	public Solution getAnswer() {
		return answer; 
	}

	public ArrayList<String> getHabitableRooms() {
		return habitableRooms; 
	}

	public Map<CardType, ArrayList<Card>> getUnseen() {
		return unseen;
	}

	public void setUnseen(Map<CardType,ArrayList<Card>> newUnseen)
	{
		unseen = newUnseen; 
	}

	public HumanPlayer getHuman()
	{
		return human;
	}
	
	public Color convertColor(String strColor) {
		Color color; 
		try {     
			// We can use reflection to convert the string to a color
			Field field = Class.forName("java.awt.Color").getField(strColor.trim().toLowerCase());     
			color = (Color)field.get(null); 
		} catch (Exception e) {  
			color = null; // Not defined  
		}
		return color;
	}
	
	public void handleClick(int rowClicked, int columnClicked)
	{
		if(targets.contains(board[rowClicked][columnClicked]))
		{
			Solution sugg = human.moveToSpot(board[rowClicked][columnClicked], this, false);
			
			targets.clear();
			repaint();
		}
		else
		{
			JOptionPane.showMessageDialog(this, "Invalid Target", "Oops!", JOptionPane.ERROR_MESSAGE);
		}
	}
	
	public class ClickOnBoard implements MouseListener{

		@Override
		public void mouseClicked(MouseEvent e) {
			int rowClicked = e.getY()/ClueGame.CELL_PIXEL_SIZE;
			int columnClicked = e.getX()/ClueGame.CELL_PIXEL_SIZE;
			handleClick(rowClicked, columnClicked);
		}

		@Override
		public void mousePressed(MouseEvent e) {
		}

		@Override
		public void mouseReleased(MouseEvent e) {
		}

		@Override
		public void mouseEntered(MouseEvent e) {
		}

		@Override
		public void mouseExited(MouseEvent e) {
		}
		
		
	}
}


